/*
	relative to the screen
	std::cout << "mouse pos realative to the screen -> " << sf::Mouse::getPosition().x << " , " << sf::Mouse::getPosition().y << std::endl;

	//relative to the window
	std::cout << "mouse pos relative to the window -> " << sf::Mouse::getPosition(*this->window).x << " , " << sf::Mouse::getPosition(*this->window).y << std::endl;
*/

static_cast<float>(rand() % static_cast<int>(this->window->getSize().y - this->enemy.getSize().y))


for (auto& e : this->enemies)
	{
		e.move(0.f, 1.f);
	}


void game::renderEnemies()
{
	//rendering all the enemies
	for (auto& e : this->enemies)
	{
		this->window->draw(e);
	}
}



void game::pollevent()
{
	//event polling

	while (this-> window->pollEvent(this->ev))	
	{
		switch (this->ev.type)
		{
		case sf::Event::Closed:
			this->window->close();
			break;
		case sf::Event::KeyPressed:
			if (ev.key.code == sf::Keyboard::Escape)
				this->window->close();
			break;
		}
	}
	//move the enemies
	/*loops from 0 to maxium no of enemies and moves enemies induvidully */

	for (int i = 0; i < this->enemies.size() ; i++)
	{
		bool deleted = false;

		this->enemies[i].move(0.f, 3.f);

		//check if clicked upon
		if (sf::Mouse::isButtonPressed(sf::Mouse::Left))
		{
			if (this->enemies[i].getGlobalBounds().contains(this->mousePosView))
			{
				deleted = true;

				//gain points

				this->points += 1.f;


			}

		}
		if (this->enemies[i].getPosition().y > this->window->getSize().y)
		{
			deleted = true;
		}
		if (deleted)
		{
			this->enemies.erase(this->enemies.begin() + i);
		}
	}
	
}

this->enemy.setScale(sf::Vector2f(0.5f,0.5f));



void game::spawnEnemy()
{
	this->enemy.setPosition(
		static_cast<float>(rand() % static_cast<int>(this->window->getSize().x - this->enemy.getSize().x)),
		0.f
	);

	//randomize enemy type
	int type = rand() % 5;
	
	switch (type)
	{
	case 0:
		this->enemy.setSize(sf::Vector2f(10.0f, 10.0f));
		this->enemy.setFillColor(sf::Color::Blue);
		break;
	case 1:
		this->enemy.setSize(sf::Vector2f(30.0f, 30.0f));
		this->enemy.setFillColor(sf::Color::Green);
		break;
	case 2:
		this->enemy.setSize(sf::Vector2f(50.0f, 50.0f));
		this->enemy.setFillColor(sf::Color::Yellow);
		break;
	case 3:
		this->enemy.setSize(sf::Vector2f(70.0f, 70.0f));
		this->enemy.setFillColor(sf::Color::Magenta);
		break;
	case 4:
		this->enemy.setSize(sf::Vector2f(100.0f, 100.0f));
		this->enemy.setFillColor(sf::Color::Red);
		break;

	default:
		this->enemy.setSize(sf::Vector2f(100.0f, 100.0f));
		this->enemy.setFillColor(sf::Color::White);
		break;

	}


	//spawn enemy

	this->enemies.push_back(this->enemy);
}

void game::pollevent()
{
	//event polling

	while (this->window->pollEvent(this->ev))
	{
		switch (this->ev.type)
		{
		case sf::Event::Closed:
			this->window->close();
			break;
		case sf::Event::KeyPressed:
			if (ev.key.code == sf::Keyboard::Escape)
				this->window->close();
			break;
		}
	}
	//move the enemies
	/*loops from 0 to maxium no of enemies and moves enemies induvidully */

	for (int i = 0; i < this->enemies.size(); i++)
	{
		bool deleted = false;

		this->enemies[i].move(0.f, 2.f);

		if (this->enemies[i].getPosition().y > this->window->getSize().y)
		{
			this->enemies.erase(this->enemies.begin() + i);
			this->health -= 1;
		}

	}
void game::spawnEnemy()
{
	this->enemy.setPosition(
		static_cast<float>(rand() % static_cast<int>(this->window->getSize().x - this->enemy.getSize().x)),
		0.f
	);

	//randomize enemy type
	int type = rand() % 5;
	
	switch (type)
	{
	case 0:
		this->enemy.setSize(sf::Vector2f(10.0f, 10.0f));
		this->enemy.setFillColor(sf::Color::Blue);
		break;
	case 1:
		this->enemy.setSize(sf::Vector2f(30.0f, 30.0f));
		this->enemy.setFillColor(sf::Color::Green);
		break;
	case 2:
		this->enemy.setSize(sf::Vector2f(50.0f, 50.0f));
		this->enemy.setFillColor(sf::Color::Yellow);
		break;
	case 3:
		this->enemy.setSize(sf::Vector2f(70.0f, 70.0f));
		this->enemy.setFillColor(sf::Color::Magenta);
		break;
	case 4:
		this->enemy.setSize(sf::Vector2f(100.0f, 100.0f));
		this->enemy.setFillColor(sf::Color::Red);
		break;

	default:
		this->enemy.setSize(sf::Vector2f(100.0f, 100.0f));
		this->enemy.setFillColor(sf::Color::White);
		break;

	}


	//spawn enemy

	this->enemies.push_back(this->enemy);
}

}


void game::spawnEnemy()
{
	this->enemy.setPosition(
		static_cast<float>(rand() % static_cast<int>(this->window->getSize().x - this->enemy.getSize().x)),
		0.f
	);

	//randomize enemy type
	int type = rand() % 5;
	
	switch (type)
	{
	case 0:
		this->enemy.setSize(sf::Vector2f(10.0f, 10.0f));
		this->enemy.setFillColor(sf::Color::Blue);
		break;
	case 1:
		this->enemy.setSize(sf::Vector2f(30.0f, 30.0f));
		this->enemy.setFillColor(sf::Color::Green);
		break;
	case 2:
		this->enemy.setSize(sf::Vector2f(50.0f, 50.0f));
		this->enemy.setFillColor(sf::Color::Yellow);
		break;
	case 3:
		this->enemy.setSize(sf::Vector2f(70.0f, 70.0f));
		this->enemy.setFillColor(sf::Color::Magenta);
		break;
	case 4:
		this->enemy.setSize(sf::Vector2f(100.0f, 100.0f));
		this->enemy.setFillColor(sf::Color::Red);
		break;

	default:
		this->enemy.setSize(sf::Vector2f(100.0f, 100.0f));
		this->enemy.setFillColor(sf::Color::White);
		break;

	}


	//spawn enemy

	this->enemies.push_back(this->enemy);
}